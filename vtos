#!/usr/bin/perl
################################################################################
# Copyright (c) 2022 Glenn Ramalho
################################################################################
# File: vtos
# Author: Glenn Ramalho
################################################################################
# Description: This script converts a Structural verilog netlist into a spice
#   or spectre netlist.
################################################################################
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################

$progname=$0;
$progname=~s#.*/##;
$version = '$Id$' . "\n";
$usage=
"usage: $progname [-hV]
       $progname [-dS] [-G globals] -i netlist.v[.gz] -o out.net [models ...]
";
$help="
This program converts a structural Verilog netlist into a Spice or Spectre
netlist.

-h     help
-V     Version
-d     debug
-G     Connect globals to nets: '-G VDD,VSS'
-i     netlist input, cam be compressed.
-o     output converted file, can't be the same as the input
-S     Use spice format. Default is spectre format.
models models to extract the pin order of library cells
";

use Getopt::Std;
getopts('hVdG:Si:o:') || die $usage . "\n";

if ($opt_h) {
   printf $usage;
   printf $help;
   exit 0;
}
if ($opt_V) {
   printf $version;
   exit 0;
}
if (!$opt_i || !$opt_o) {
   warn "$progname: the -i and -o options are necessary.\n";
   die $usage . "\n";
}
if ($opt_i eq $opt_o) {
   warn "$progname: the -i and -o must not be the same.\n";
   die $usage . "\n";
}

###################
# Sub nl
# inputs: line to clean
# outputs: returns the processed line
# globals: none
#
# Takes a verilog netlist line and strips comments, configuration and white
# spaces. Also adds space before and after the parenthesis to make it easier
# to parse.
#
sub nl {
  local ($nl) = @_;
  chomp $nl;
  $nl =~ s/\(\*.*\*\)//;
  $nl =~ s#//.*##;
  $nl =~ s/^[  ]+//;
  $nl =~ s/[  ]$//;
  $nl =~ s/\(/ ( /;
  $nl =~ s/\)/ ) /;

  $nl;
}

###################
# Sub fmt
# inputs: line to print
# outputs: none
# globals: OUT, $opt_S
#
# Prints a line reformatting it to fit in 78 columns. It will break the line.
# It also elimitates illegal characters in the process.
#
sub fmt {
   local (@w) = @_;
   local ($i, $l, $line);

   $l = length($w[0]);
   $line = $w[0];
   foreach $_ (@w[1..$#w]) {
      $l = $l + length($_) + 1;
      if ($l > 78) {
         $line =~ s/\[/</g;
         $line =~ s/\]/>/g;
         $line =~ s/-/m/g;

         # The continuation character depends on the output format.
         if ($opt_S) {
            print OUT $line, "\n";
            $line = "+  $_";
         } else {
            print OUT $line, " \\\n";
            $line = "   $_";
         }
         $l = length($line);
      } else {
         $line = $line . " $_";
      }
   }
   $line =~ s/\[/</g;
   $line =~ s/\]/>/g;
   $line =~ s/-/m/g;
   print OUT $line, "\n";
}

###################
# Sub expbusses
# inputs: line with busses to expand
# outputs: expanded line
# globals: none
#
# Finds verilog bus vectors with [] and expands them into individual bits.
# V[5:3] becomes V[5], V[4], V[3]
#
sub expbusses {
   local ($line) = @_;
   local ($bus, $fullbus, @explist, $p, $l, $bit);

   while($line =~ m/([^ \t,()]+)\s*\[([\d-]+):([\d-]+)\]/) {
      # We now collect the data in the bus and located the string.
      $bus = $1;
      $left = $2;
      $right = $3;
      $fullbus = $&;
      $p = index $line, $&;
      $l = length $fullbus;

      # Now we build a list of expanded entries.
      @explist = ();
      for ($bit = $left; $bit >= $right; $bit = $bit - 1) {
         push @explist, "$bus<$bit>";
      }

      # We join it into a comma separated strings and insert it back into
      # the string.
      $expbus = join ", ", @explist;
      substr($line, $p, $l, $expbus);
   }

   $line;
}

###################
# Sub exppins
# inputs: line with pins to expand
# outputs: expanded line
# globals: $opt_d, OUT, %left and %right
#
# Replaces pin connections in the format .pin ( { a, b, c} ) with .pin<2>(a),
# .pin<1>(b), .pin<0>(c).
#
sub exppins {
   local($module,$line) = @_;
   local($bus, $p, $pin, $l, @bus, $i, @flatbus, $newnet);

   while($line =~ m/\.([^ \t,()]+)\s*\(([^()]*,[^()]*)\)/
         || $line =~ m/\.([^ \t,()]+)\s*\(\s*\{[^()]*\}\s*\)/) {
      print OUT "   * Expanding pin $&\n" if $opt_d;
      # First we locate the string in the $_.
      $fullbus = $&;
      $pin = $1;
      $bus = $2;
      $p = index $line, $fullbus; 
      $l = length $fullbus;

      # Now we remove the concatenation brackets and extract the bus elements
      $bus =~ s/{//;
      $bus =~ s/}//;
      $bus =~ s/^\s+//;
      $bus =~ s/\s+$//;
      @bus = split /[ \t]*,[ \t]*/, $bus;

      # Now we find the left for the pin.
      if (! defined $left{$module,$pin} ) {
         $left = $#bus;
         print OUT "  * Using guess ($pin) left = $left\n" if $opt_d;
      } else {
         $left = $left{$module,$pin};
         print OUT "  * Using $pin left = $left\n" if $opt_d;
      }

      # We now make a new pin for each entry.
      @flatbus = ();
      for ($i = 0; $i <= $#bus; $i = $i + 1) {
         push @flatbus, ".$pin<" . ($left - $i) . "> (" . $bus[$i] . ")";
      }

      # Now we bring in the flatten bus in.
      $newnet = join ", ", @flatbus;
      print OUT "   * Expanded to $newnet\n" if $opt_d;
      substr $line, $p, $l, $newnet;
   }

   $line;
}

################################################################################
# We first open the netlist. If the file ends in .gz it must be gzipped. We
# unzip it and read it then.
if ($opt_i =~ m/\.gz$/) {
   open (NET, "gunzip -c $opt_i|") || die "$progname: $opt_i: $!\n";
} else {
   open (NET, $opt_i) || die "$progname: $opt_i: $!\n";
}

# Now we open the output file.
open OUT, ">$opt_o" || die "$progname: open $opt_o: $!\n";

# We read any models that may be on the end.
for $model (@ARGV) {
   print "* Reading the spice model $model\n";
   print OUT "* Reading the spice model $model\n";
   open (FILE, "$model") || die "$progname: $model: $!\n";
   while(<FILE>) {
      s/[;*].*//;
      s/^\s+//;
      s/\s+$//;
      next if m/^$/;
      @_ = split /[, \t]+/;

      if (lc($_[0]) eq ".subckt") {
         split /[ \t]+/;
         $subckt = $_[1];
         @{$pins{$subckt}} = @_[2..$#_];
         if ($opt_d) {
            print OUT "* Found SUBCKT $_[1]\n";
         }
      }
   }
   close FILE;
}

# The globals, if any, are in opt_G.
if ($opt_G) {
   @globals = split /[ \t]*,[ \t]*/, $opt_G;
   foreach $g (@globals) {
      $globals{$g} = 1;
   }
   print "* Using globals ", join(", ", @globals), "\n";
   print OUT "* Using globals ", join(", ", @globals), "\n";
}

# And we are ready to process the netlist.
print "* Reading netlist $opt_i\n";
$unc = 0;
$modstarted = 0;
$module = "";
while(<NET>) {
   # Remove whitespace
   $_ = nl($_);
   next if m/^$/;
   last if m/`ifdef/;

   # When we find the endmodule we close the subckt.
   if (/endmodule/) {
      print OUT "ends $module\n";
      $module = ""; 
      next;
   }

   # If a line does not end in a semicolon, we merge it with the next line.
   # We need to stop if we hit the end of file.
   while ($_ !~ /;$/ && ! eof(NET) ) {
      $_ = nl($_ . <NET>);
   }

   # We no longer need the semicolon.
   s/\s*;$//;

   # Once we hit here we can split the line.
   @_ = split /[, \t]+/;

   # Any line with a pin or wire keyword we capture to know if it is a bus
   if ($_[0] eq "input" || $_[0] eq "output" || $_[0] eq "inout" ||
         $_[0] eq "wire") {
      if ($_[1] =~ /\[(.*):(.*)\]/) {
         $left = $1;
         $right = $2;
      } elsif ($_[1] =~ /\[(.*)\]/) {
         $left = $1;
         $right = $1;
      } else {
         $left = "";
         $right = "";
      }

      if ($left ne "") {
         for $pin (@_[2..$#_]) {
            if ($opt_d && $_[0] eq "wire") {
               print OUT "* Found wire bus $module.$pin -> $left:$right\n";
            } elsif ($opt_d) {
               print OUT "* Found pin bus $module.$pin -> $left:$right\n";
            }
            $left{$module,$pin} = $left;
            $right{$module,$pin} = $right;
         }
      }
      next;
   }

   # We have no special treatment for the supplies. We also can ditch the wires.
   if ($_[0] eq "supply0" || $_[0] eq "supply1" || $_[0] eq "wire") {
      next;
   }

   # If it is a module we need the module name
   if ($_[0] eq "module") {
      # We get the module and the pins
      $module = $_[1];
      @pins = @_[3..$#_-1];
      print "* module $module\n";
      print OUT "* Found module $module has pins ", join(", ", @pins), "\n"
         if $opt_d;

      # And we tag that we are doing a new module.
      $modstarted = 1;

   # If we see an instance, we build an instance block. It is quite similar
   # to the verilog one, just the arguments change a bit.
   } else {
      # If this is the first line after the pins, we need to expand any busses
      # in the pinlist first.
      if ($modstarted) {
         @epins = ();
         for($i = 0; $i <= $#pins; $i = $i + 1) {
            $pin = $pins[$i];
            if (! defined $left{$module,$pin}) {
               push @epins, $pin;
            } elsif ($left{$module,$pins} == $right{$module,$pin}) {
               push @epins, "$pin<$left{$module,$pin}>";
            } else {
               $pinlist = expbusses($pin .
                  "[$left{$module,$pin}:$right{$module,$pin}]");
               push @epins, split / *, */, $pinlist;
            }
         }

         @{$pins{$module}} = @epins;
         print OUT "\n";
         fmt "subckt", $module, @{$pins{$module}};

         $modstarted = 0;
      }

      $block = $_[0];
      $inst = $_[1];

      # We first collect the busses.
      $oldline = $_;
      @pins = m/\.[^ \t,()]+\s*\([^()]+\)/g;
      for $pin (@pins) {
         # We mark it
         $pin =~ m/(.*)\((.*)\)/;
         $pinname = $1;
         $pinbus = $2;
         $p = index $_, $pin;
         $l = length $pin;
         
         # We remove any concatenation keys
         $pinbus =~ s/{//g;
         $pinbus =~ s/}//g;
         $pinbus =~ s/^\s+//g;
         $pinbus =~ s/\s+$//g;

         # We now scan it looking for unexpanded busses.
         @bus = split /[ \t]*,[ \t]*/, $pinbus;
         @bits = ();
         for $bit (@bus) {
            if (!defined $left{$block,$bit}) {
               push @bits, $bit;
            } elsif (defined $left{$block,$bit} &&
                  $left{$block,$bit} == $right{$block,$bit}) {
               push @bits, $bit . "<" . $left{$block,$bit} . ">";
            } else {
               $bitlist = expbusses($bit .
                  "[$left{$block,$bit}:$right{$block,$bit}]");
               push @bits, split /,/, $bitlist;
            }
         }
         
         # And we bring the new list in
         $newline = "$pinname(" . join(", ",@bits) . ")";
         substr $_, $p, $l, $newline;
      }

      # We need to expand any explicit busses.
      $_ = expbusses($_);

      # Now we look for .pin(a, b, c) and replace it with .pin<2>(a),
      # .pin<1>(b), .pin<0>(c).
      $_ = exppins($block,$_);

      print OUT "* was: $oldline\n* now: $_\n" if $oldline ne $_ && $opt_d;

      # If the device has no pins, it can't be too complex, it must be missing.
      # So we just print a warning and skip it.
      if (! defined $pins{$block}) {
         print OUT "* block $block inst $inst not found\n";
         next;
      }

      # We need to rearrange the pins into the order that they are in the
      # device.
      @pins = ();
      foreach $pin (@{$pins{$block}}) {
         # Single bit inputs do not need to have the bus mentioned.
         $nobus = $pin;
         $nobus =~ s/<[\d-]+>//;
         # For every pin we find, we need to know where it is located in the
         # instance as Spice does not support connect-by-name.
         if ($_ =~ m/\.$pin\s*\(([^()]*)\)/) {
            $net = $1;
            $net =~ s/^\s+//;
            $net =~ s/\s+$//;
         } elsif ($_ =~ m/\.$nobus\s*\(([^()]*)\)/) {
            $net = $1;
            $net =~ s/^\s+//;
            $net =~ s/\s+$//;
         } elsif (defined $globals{$pin}) {
            $net = $pin;
         } else {
            $net = "UNCON_$unc";
            $unc = $unc + 1;
         }
         push @pins, $net;
         print OUT "* Connected Pin $pin<$block> to net $net\n" if $opt_d;
      }
      
      # And we can generate the instance. Note that in spice format all
      # subcircuits must begin with an X.
      fmt ((($opt_S) ? "X" . $inst : $inst), @pins, $block);
   }
}

close NET if $opt_i ne '-';
close OUT if $opt_o ne '-';

exit 0;
